import functools
import json
from socket import SocketType
import subprocess
from time import sleep, time
from typing import List, Set, Tuple
from os import cpu_count, path, rename
from _thread import start_new_thread
import bpy
from bpy.types import Operator, Context, Object
from tempfile import gettempdir

from .server import JFractureServer, SocketSignal


CPU_COUNT = cpu_count()
MODULE_PATH = path.dirname(path.abspath(__file__))
SCRIPT_PATH = path.join(MODULE_PATH, 'script.py')
SETTINGS_PATH = path.join(MODULE_PATH, 'settings.json')
BLEND_PATH = path.join(MODULE_PATH, 'empty.blend')
TMP_DIR = gettempdir()
COPYBUFFER_PATH = path.join(TMP_DIR, 'coppybuffer.blend')


def split(a, n):
    k, m = divmod(len(a), n)
    return (a[i*k+min(i, m):(i+1)*k+min(i+1, m)] for i in range(n))


def get_layer_coll(layer_coll, collection):
    if (layer_coll.collection == collection):
        return layer_coll
    for layer in layer_coll.children:
        layer_coll = get_layer_coll(layer, collection)
        if layer_coll:
            return layer_coll
    return None


class JFRACTURE_OT_cell_fracture(Operator):
    bl_idname: str = 'jfracture.cell_fracture'
    bl_label: str = "Cell Fracture"
    bl_description: str = "Multi-Thread based cell fracture"


    def init(self, context) -> None:
        self.start_time = time()
        self.timer = None

        # Write cf props to settings json.
        data = {}
        with open(SETTINGS_PATH, 'w') as json_file:
            json_string = json.dumps(data)
            json_file.write(json_string)

        # Deselect objects.
        for ob in self.objects:
            ob.select_set(False)

        # Resolve objects per instance.
        ob_count: int = len(self.objects)
        instances_count: int = min(CPU_COUNT, ob_count)
        self.instances_count = instances_count
        if instances_count == ob_count:
            self.instance_objects = [[ob] for ob in self.objects]
        else:
            # ob_count > instances_count
            self.instance_objects: List[List[Object]] = split(self.objects, instances_count)

        # Inter-Client properties.
        self.finished = [False] * instances_count
        self.request_queue = []

        # Start server.
        self.server = JFractureServer(instances_count)
        self.server.start()

        # Export objects:
        self.export_objects(context)


    def error(self, msg: str) -> None:
        self.report({'ERROR'}, msg)
        return {'CANCELLED'}


    def finish(self, context: Context) -> None:
        self.server.stop()

        if self.timer:
            context.window_manager.event_timer_remove(self.timer)
            self.timer = None

        tot_time = time() - self.start_time
        time_msg = "Total Time: %.2f" % (tot_time)
        self.report({'INFO'}, time_msg)
        print(time_msg)
        return {'FINISHED'}


    def execute(self, context: Context) -> Set[str]:
        if CPU_COUNT == 0:
            return self.error("No CPU! Please, buy new computer")

        if len(context.selected_objects) == 0:
            return self.error("No Selected Objects!")

        filt_objects: List[Object] = [ob for ob in context.selected_objects if ob.type=='MESH' and ob.visible_get()]
        if not filt_objects:
            return self.error("No Selected MESH Objects!")

        #if any([bool(ob.modifiers) for ob in filt_objects]):
        #    return self.error("Please, apply or remove modifiers from selected objects")

        self.objects = filt_objects
        self.init(context)

        self.timer = context.window_manager.event_timer_add(0.1, window=context.window)
        context.window_manager.modal_handler_add(self)
        return {'RUNNING_MODAL'}


    def modal(self, context: Context, event) -> Set[str]:
        #print(event.type, event.value)
        if not event.type.startswith('TIMER'):
            return {'RUNNING_MODAL'}

        # Workaround to safely resolve the client requests without conflicts between
        # the different threads that hold the connections with the clients.
        while self.request_queue != []:
            client_id, request, client = self.request_queue.pop(0)
            if request == SocketSignal.FINISHED:
                print("[Server] Client-%i just finished!" % client_id)
                self.finished[client_id] = True
                lib_path = path.join(TMP_DIR, 'pastebuffer' + str(client_id) + '.blend')
                # Load output fracture collections from client output.
                with bpy.data.libraries.load(lib_path) as (data_from, data_to):
                    data_to.collections = data_from.collections
                link_coll = context.scene.collection.children.link
                for collection in data_to.collections:
                    if collection is not None:
                        link_coll(collection)
                print("[Server] Chunks generated by Client-%i were loaded successfully!" % client_id)
            else:
                print("Woot!?")

        if all(self.finished):
            print("[Server] DONE!")
            return self.finish(context)

        return {'RUNNING_MODAL'}


    def client_handler(self, client: SocketType): #, client_id: int):
        print('[Server] Started New Thread.')
        with client:
            while 1:
                #print("holiwoli")
                try:
                    data: Tuple[int, int] = self.server.rcv_signal(client)
                    if data is None:
                        continue

                    instance_id, signal = data
                    print(f"[Server] Received signal {signal} from instance {instance_id}")

                    # Safe method.
                    self.request_queue.append((instance_id, signal, client))
                    sleep(0.1)
                    continue

                except Exception as e:
                    print(e)
                    break


    def start_instance(self, objects: List[Object], instance_id: str) -> None:
        # Start instance.
        process = subprocess.Popen(
            [
                bpy.app.binary_path, # sys.executable,
                BLEND_PATH,
                '--background',
                '--python',
                SCRIPT_PATH,
                '--', # Blender is silly and stops with this.
                # Now the arguments...
                str(self.server.port),
                instance_id, # ID.
                ','.join([ob.name for ob in objects])
            ],
            shell=False)


    def export_objects(self, context):
        print("[Operator] Export Objects to fracture.")
        for idx, objects in enumerate(self.instance_objects):
            print("[Client-%i] Initializing..." % idx)

            output_path: str = path.join(TMP_DIR, 'coppybuffer' + str(idx) + '.blend')
            bpy.data.libraries.write(output_path, set(objects))
            
            for ob in objects:
                print("\t%i. %s" % (idx, ob.name))
                ob.select_set(False)
                ob.hide_set(True)

            self.start_instance(objects, str(idx))

            try:
                client, address = self.server.new_connection()
            except Exception as e:
                print(e)
                return None
            print('[Server] Connected to: ' + address[0] + ':' + str(address[1]))
            start_new_thread(self.client_handler, (client, ))
